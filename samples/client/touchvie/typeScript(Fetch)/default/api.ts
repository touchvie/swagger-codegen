/**
 * Dive API
 * This is the Dive third party API official documentation
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://pre-api.touchvie.com/v1";

export interface FetchArgs {
    url: string;
    options: any; 
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface AccessToken {
    /**
     * Auth token, must be included on every API request
     */
    "accessToken"?: string;
    /**
     * Token type
     */
    "tokenType"?: AccessTokenTokenTypeEnum;
    /**
     * Allows to issue new access tokens without resending client credentials
     */
    "refreshToken"?: string;
    /**
     * Expiration time (in seconds).
     */
    "expiresIn"?: number;
    /**
     * Granted auth scope
     */
    "scope"?: AccessTokenScopeEnum;
}

export type AccessTokenTokenTypeEnum = "bearer";
export type AccessTokenScopeEnum = "device";
export interface AuthError {
    /**
     * Short error identifier
     */
    "error"?: string;
    /**
     * Extended error description
     */
    "errorDescription"?: string;
}

/**
 * Award nominee or winner info
 */
export interface AwardData {
    /**
     * Name of the prize
     */
    "title": string;
    /**
     * Name of the nominee / winner
     */
    "value": string;
}

/**
 * CardContainer composed by a list of awards with nominees and winners
 */
export interface Awards extends CardContainer {
    /**
     * Awards container content type
     */
    "contentType": AwardsContentTypeEnum;
    "data": Array<AwardsData>;
}

export type AwardsContentTypeEnum = "awards";
export interface AwardsData {
    /**
     * Award name
     */
    "title": string;
    "nominee"?: Array<AwardData>;
    "winner"?: Array<AwardData>;
}

/**
 * Basic Dive data unit, represents an item of a given category
 */
export interface Card {
    /**
     * Card unique identifier
     */
    "cardId": string;
    /**
     * Card version for a given movie and scene
     */
    "version"?: string;
    /**
     * Card type
     */
    "type": CardTypeEnum;
    /**
     * Card content locale
     */
    "locale": string;
    /**
     * Card title
     */
    "title": string;
    /**
     * Card subtitle (might be empty)
     */
    "subtitle"?: string;
    "image"?: ImageData;
    "info"?: Array<CardContainer>;
    "relations"?: Array<RelationModule>;
}

export type CardTypeEnum = "movie" | "serie" | "person" | "character" | "vehicle" | "fashion" | "location" | "historic" | "trivia" | "quote" | "ost" | "home" | "technology" | "art" | "song" | "look" | "weapon" | "leisure_sport" | "health_beauty" | "food_drink" | "fauna_flora" | "business" | "reference" | "chapter";
/**
 * Card static data container. It's content depends on the 'type' parameter value and is represented by the schema of the same name
 */
export interface CardContainer {
    /**
     * Card container format type, determines the format of the 'data' field
     */
    "type": CardContainerTypeEnum;
}

export type CardContainerTypeEnum = "text" | "listing" | "rating" | "map" | "link" | "awards" | "catalog" | "seasons" | "image";
/**
 * CardContainer composed by additional information of a catalog item (movie, serie or chapter)
 */
export interface Catalog extends CardContainer {
    /**
     * Catalog container content type
     */
    "contentType": CatalogContentTypeEnum;
    "data": Array<CatalogData>;
}

export type CatalogContentTypeEnum = "movie" | "chapter" | "serie";
export interface CatalogData {
    /**
     * URL of an additional background image for this catalog element
     */
    "backgroundImage"?: string;
    /**
     * Name of the director
     */
    "director": string;
    /**
     * List of genres of this catalog entry
     */
    "genres": Array<string>;
    /**
     * Original language title
     */
    "originalTitle": string;
    /**
     * Length of the movie or chapter, or average length of serie chapters, in minutes
     */
    "runtime": number;
    /**
     * Year of production
     */
    "year": number;
    /**
     * Index of the chapter inside its season (only for content_type=chapter)
     */
    "chapterIndex"?: number;
    /**
     * Index of the season where the chapter belongs (only for content_type=chapter)
     */
    "seasonIndex"?: number;
    "sync"?: CatalogSync;
}

/**
 * Dive interactive capabilities of this catalog item
 */
export interface CatalogSync {
    /**
     * Indicates if this catalog item can be synchronized
     */
    "isSynchronizable": boolean;
}

export interface ChannelStatus {
    /**
     * Provided channel ID
     */
    "channelId"?: string;
    /**
     * True if channel is broadcasting synchronizable content, False otherwise
     */
    "ready"?: boolean;
}

/**
 * List of related pairs of cards, each pair having a relationship type between both cards
 */
export interface Duple extends RelationModule {
    /**
     * Duple module content type, defines what kind of relations are contained in the module
     */
    "contentType": DupleContentTypeEnum;
    "data": Array<DupleData>;
}

export type DupleContentTypeEnum = "casting" | "filmography" | "played_by" | "worn_by" | "featured_in";
export interface DupleData {
    /**
     * Indicates the relationship between the pair of cards (from > rel_type > to)
     */
    "relType": string;
    "from": Card;
    "to"?: Card;
}

/**
 * CardContainer composed by a list of images with source attribution
 */
export interface Image extends CardContainer {
    /**
     * Image container content type
     */
    "contentType": ImageContentTypeEnum;
    "data": Array<ImageData>;
}

export type ImageContentTypeEnum = "gallery";
/**
 * Linked image URL and additional information
 */
export interface ImageData {
    /**
     * Image thumbnail URL
     */
    "thumb": string;
    /**
     * Full size image URL
     */
    "full": string;
    /**
     * Image anchor X axis (percent)
     */
    "anchorX": number;
    /**
     * Image anchor Y axis (percent)
     */
    "anchorY": number;
    "source": SourceData;
}

/**
 * CardContainer composed by a list of links to external media resources with source attribution
 */
export interface Link extends CardContainer {
    /**
     * Link container content type
     */
    "contentType": LinkContentTypeEnum;
    "data": Array<LinkData>;
}

export type LinkContentTypeEnum = "trailer" | "video" | "music";
export interface LinkData {
    /**
     * URL of the external resource
     */
    "url": string;
    "source": SourceData;
}

/**
 * CardContainer composed by a list of pairs of label - value items
 */
export interface Listing extends CardContainer {
    /**
     * Listing container content type
     */
    "contentType": ListingContentTypeEnum;
    "data": Array<ListingData>;
}

export type ListingContentTypeEnum = "basic_data" | "specs";
export interface ListingData {
    /**
     * Item label
     */
    "text": string;
    /**
     * Item value
     */
    "value": string;
}

/**
 * CardContainer composed by a map of a given location
 */
export interface Map extends CardContainer {
    /**
     * Map container content type
     */
    "contentType": MapContentTypeEnum;
    "data": Array<MapData>;
}

export type MapContentTypeEnum = "location";
export interface MapData {
    /**
     * Value of the location latitude, in decimal format degrees
     */
    "latitude": number;
    /**
     * Value of the location longitude, in decimal format degrees
     */
    "longitude": number;
    /**
     * Zoom value, defines the height coordinate over the given location
     */
    "zoom": number;
}

export interface MovieStatus {
    /**
     * Provided client movie ID
     */
    "movieId"?: string;
    /**
     * True if movie can be synchronized via this API, False otherwise.
     */
    "ready"?: boolean;
}

/**
 * CardContainer composed by a list of external ratings with source attribution
 */
export interface Rating extends CardContainer {
    /**
     * Rating container content type
     */
    "contentType": RatingContentTypeEnum;
    "data": Array<RatingData>;
}

export type RatingContentTypeEnum = "rating";
export interface RatingData {
    /**
     * Rating value
     */
    "value": string;
    "source"?: SourceData;
}

/**
 * Relation modules provide lists of cards related to the current one. It's contents depend on the module 'type' attribute
 */
export interface RelationModule {
    /**
     * Relation module type, defines the contained data structure
     */
    "type": RelationModuleTypeEnum;
}

export type RelationModuleTypeEnum = "single" | "duple";
/**
 * Serie seasons listing
 */
export interface Seasons extends CardContainer {
    /**
     * Seasons container content type
     */
    "contentType": SeasonsContentTypeEnum;
    "data": Array<SeasonsData>;
}

export type SeasonsContentTypeEnum = "seasons";
export interface SeasonsChapters {
    /**
     * Index of the chapter inside this season
     */
    "chapterIndex": number;
    /**
     * ID of the chapter card
     */
    "cardId": string;
}

export interface SeasonsData {
    /**
     * Index of the season
     */
    "seasonIndex": number;
    /**
     * Comma separated list of season creators
     */
    "creators": string;
    "image": ImageData;
    /**
     * Year of production of this season
     */
    "year": number;
    /**
     * List of season chapters
     */
    "chapters": Array<SeasonsChapters>;
}

/**
 * List of related single cards. The relation type is defined by the module content type
 */
export interface Single extends RelationModule {
    /**
     * Single module content type, defines what kind of relations are contained in the module
     */
    "contentType": SingleContentTypeEnum;
    "data": Array<Card>;
}

export type SingleContentTypeEnum = "trivias" | "directors" | "appears_in" | "full_looks" | "look_fashion" | "fashion_set" | "full_home" | "home_deco" | "tracklist" | "sounds_in" | "is_part_of" | "is_chapter_of" | "wears";
/**
 * Information regarding the source of any API item
 */
export interface SourceData {
    /**
     * Name of the source
     */
    "name": string;
    /**
     * URL of the source
     */
    "url": string;
    /**
     * Disclaimer text of the source
     */
    "disclaimer"?: string;
    /**
     * URL of the source icon
     */
    "image"?: string;
}

/**
 * CardContainer composed by a block of text with an optional source attribution
 */
export interface Text extends CardContainer {
    /**
     * Text container content type
     */
    "contentType": TextContentTypeEnum;
    "data": Array<TextData>;
}

export type TextContentTypeEnum = "overview" | "curiosity" | "description" | "biography" | "reference" | "quote";
export interface TextData {
    /**
     * Informational text
     */
    "text": string;
    "source"?: SourceData;
}



/**
 * DefaultApi - fetch parameter creator
 */
export const DefaultApiFetchParamCreactor = {
    /** 
     * Full card detail
     * Retrieves a full card detail, and optionally its relations to other cards
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Provided card ID (value of the &#39;card_id&#39; field)
     * @param version Provided card version (value of the &#39;version&#39; field)
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    cardsCardIdVersionsVersionGet(params: {  authorization: string; cardId: string; version: string; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling cardsCardIdVersionsVersionGet");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling cardsCardIdVersionsVersionGet");
        }
        // verify required parameter "version" is set
        if (params["version"] == null) {
            throw new Error("Missing required parameter version when calling cardsCardIdVersionsVersionGet");
        }
        const baseUrl = `/cards/{card_id}/versions/{version}`
            .replace(`{${"card_id"}}`, `${ params.cardId }`)
            .replace(`{${"version"}}`, `${ params.version }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "relations": params.relations,
            "image_size": params.imageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Channel sync availability
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    channelsChannelIdListReadyGet(params: {  authorization: string; channelIdList: Array<string>; acceptLanguage?: string; contentType?: string; }): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling channelsChannelIdListReadyGet");
        }
        // verify required parameter "channelIdList" is set
        if (params["channelIdList"] == null) {
            throw new Error("Missing required parameter channelIdList when calling channelsChannelIdListReadyGet");
        }
        const baseUrl = `/channels/{channel_id_list}/ready`
            .replace(`{${"channel_id_list"}}`, `${ params.channelIdList }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * One-shot channel scene
     * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    channelsChannelIdStaticGet(params: {  authorization: string; channelId: string; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling channelsChannelIdStaticGet");
        }
        // verify required parameter "channelId" is set
        if (params["channelId"] == null) {
            throw new Error("Missing required parameter channelId when calling channelsChannelIdStaticGet");
        }
        const baseUrl = `/channels/{channel_id}/static`
            .replace(`{${"channel_id"}}`, `${ params.channelId }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "relations": params.relations,
            "image_size": params.imageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Movie sync availability
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    moviesClientMovieIdListReadyGet(params: {  authorization: string; clientMovieIdList: Array<string>; acceptLanguage?: string; contentType?: string; }): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling moviesClientMovieIdListReadyGet");
        }
        // verify required parameter "clientMovieIdList" is set
        if (params["clientMovieIdList"] == null) {
            throw new Error("Missing required parameter clientMovieIdList when calling moviesClientMovieIdListReadyGet");
        }
        const baseUrl = `/movies/{client_movie_id_list}/ready`
            .replace(`{${"client_movie_id_list"}}`, `${ params.clientMovieIdList }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * One-shot movie scene
     * Retrieves the current list of cards related to the given movie scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    moviesClientMovieIdStaticTimestampGet(params: {  authorization: string; clientMovieId: string; timestamp: number; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling moviesClientMovieIdStaticTimestampGet");
        }
        // verify required parameter "clientMovieId" is set
        if (params["clientMovieId"] == null) {
            throw new Error("Missing required parameter clientMovieId when calling moviesClientMovieIdStaticTimestampGet");
        }
        // verify required parameter "timestamp" is set
        if (params["timestamp"] == null) {
            throw new Error("Missing required parameter timestamp when calling moviesClientMovieIdStaticTimestampGet");
        }
        const baseUrl = `/movies/{client_movie_id}/static/{timestamp}`
            .replace(`{${"client_movie_id"}}`, `${ params.clientMovieId }`)
            .replace(`{${"timestamp"}}`, `${ params.timestamp }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "relations": params.relations,
            "image_size": params.imageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Token endpoint
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    tokenPost(params: {  authorization: string; grantType: string; acceptLanguage?: string; contentType?: string; deviceId?: string; refreshToken?: string; }): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling tokenPost");
        }
        // verify required parameter "grantType" is set
        if (params["grantType"] == null) {
            throw new Error("Missing required parameter grantType when calling tokenPost");
        }
        const baseUrl = `/token`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "grant_type": params.grantType,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({ 
            "device_id": params.deviceId,
            "refresh_token": params.refreshToken,
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = {
    /** 
     * Full card detail
     * Retrieves a full card detail, and optionally its relations to other cards
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Provided card ID (value of the &#39;card_id&#39; field)
     * @param version Provided card version (value of the &#39;version&#39; field)
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    cardsCardIdVersionsVersionGet(params: { authorization: string; cardId: string; version: string; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Card> {
        const fetchArgs = DefaultApiFetchParamCreactor.cardsCardIdVersionsVersionGet(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Channel sync availability
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    channelsChannelIdListReadyGet(params: { authorization: string; channelIdList: Array<string>; acceptLanguage?: string; contentType?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<ChannelStatus>> {
        const fetchArgs = DefaultApiFetchParamCreactor.channelsChannelIdListReadyGet(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * One-shot channel scene
     * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    channelsChannelIdStaticGet(params: { authorization: string; channelId: string; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<Card>> {
        const fetchArgs = DefaultApiFetchParamCreactor.channelsChannelIdStaticGet(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Movie sync availability
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    moviesClientMovieIdListReadyGet(params: { authorization: string; clientMovieIdList: Array<string>; acceptLanguage?: string; contentType?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<MovieStatus>> {
        const fetchArgs = DefaultApiFetchParamCreactor.moviesClientMovieIdListReadyGet(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * One-shot movie scene
     * Retrieves the current list of cards related to the given movie scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    moviesClientMovieIdStaticTimestampGet(params: { authorization: string; clientMovieId: string; timestamp: number; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<Card>> {
        const fetchArgs = DefaultApiFetchParamCreactor.moviesClientMovieIdStaticTimestampGet(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Token endpoint
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    tokenPost(params: { authorization: string; grantType: string; acceptLanguage?: string; contentType?: string; deviceId?: string; refreshToken?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = DefaultApiFetchParamCreactor.tokenPost(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /** 
     * Full card detail
     * Retrieves a full card detail, and optionally its relations to other cards
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Provided card ID (value of the &#39;card_id&#39; field)
     * @param version Provided card version (value of the &#39;version&#39; field)
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    cardsCardIdVersionsVersionGet(params: {  authorization: string; cardId: string; version: string; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }) {
        return DefaultApiFp.cardsCardIdVersionsVersionGet(params)(this.fetch, this.basePath);
    }
    /** 
     * Channel sync availability
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    channelsChannelIdListReadyGet(params: {  authorization: string; channelIdList: Array<string>; acceptLanguage?: string; contentType?: string; }) {
        return DefaultApiFp.channelsChannelIdListReadyGet(params)(this.fetch, this.basePath);
    }
    /** 
     * One-shot channel scene
     * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    channelsChannelIdStaticGet(params: {  authorization: string; channelId: string; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }) {
        return DefaultApiFp.channelsChannelIdStaticGet(params)(this.fetch, this.basePath);
    }
    /** 
     * Movie sync availability
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    moviesClientMovieIdListReadyGet(params: {  authorization: string; clientMovieIdList: Array<string>; acceptLanguage?: string; contentType?: string; }) {
        return DefaultApiFp.moviesClientMovieIdListReadyGet(params)(this.fetch, this.basePath);
    }
    /** 
     * One-shot movie scene
     * Retrieves the current list of cards related to the given movie scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    moviesClientMovieIdStaticTimestampGet(params: {  authorization: string; clientMovieId: string; timestamp: number; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }) {
        return DefaultApiFp.moviesClientMovieIdStaticTimestampGet(params)(this.fetch, this.basePath);
    }
    /** 
     * Token endpoint
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    tokenPost(params: {  authorization: string; grantType: string; acceptLanguage?: string; contentType?: string; deviceId?: string; refreshToken?: string; }) {
        return DefaultApiFp.tokenPost(params)(this.fetch, this.basePath);
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Full card detail
         * Retrieves a full card detail, and optionally its relations to other cards
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param cardId Provided card ID (value of the &#39;card_id&#39; field)
         * @param version Provided card version (value of the &#39;version&#39; field)
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
         * @param imageSize Size of the images returned in the response
         */
        cardsCardIdVersionsVersionGet(params: {  authorization: string; cardId: string; version: string; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }) {
            return DefaultApiFp.cardsCardIdVersionsVersionGet(params)(fetch, basePath);
        },
        /** 
         * Channel sync availability
         * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param channelIdList List of client channel IDs as a comma separated list
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         */
        channelsChannelIdListReadyGet(params: {  authorization: string; channelIdList: Array<string>; acceptLanguage?: string; contentType?: string; }) {
            return DefaultApiFp.channelsChannelIdListReadyGet(params)(fetch, basePath);
        },
        /** 
         * One-shot channel scene
         * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param channelId Client channel ID
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
         * @param imageSize Size of the images returned in the response
         */
        channelsChannelIdStaticGet(params: {  authorization: string; channelId: string; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }) {
            return DefaultApiFp.channelsChannelIdStaticGet(params)(fetch, basePath);
        },
        /** 
         * Movie sync availability
         * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         */
        moviesClientMovieIdListReadyGet(params: {  authorization: string; clientMovieIdList: Array<string>; acceptLanguage?: string; contentType?: string; }) {
            return DefaultApiFp.moviesClientMovieIdListReadyGet(params)(fetch, basePath);
        },
        /** 
         * One-shot movie scene
         * Retrieves the current list of cards related to the given movie scene
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientMovieId Client movie ID being played
         * @param timestamp Current movie timestamp in seconds
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
         * @param imageSize Size of the images returned in the response
         */
        moviesClientMovieIdStaticTimestampGet(params: {  authorization: string; clientMovieId: string; timestamp: number; acceptLanguage?: string; contentType?: string; relations?: boolean; imageSize?: string; }) {
            return DefaultApiFp.moviesClientMovieIdStaticTimestampGet(params)(fetch, basePath);
        },
        /** 
         * Token endpoint
         * The token endpoint is used to obtain access tokens which allow clients to make API requests
         * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
         * @param grantType Grant type used to obtain the token.
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
         * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
         */
        tokenPost(params: {  authorization: string; grantType: string; acceptLanguage?: string; contentType?: string; deviceId?: string; refreshToken?: string; }) {
            return DefaultApiFp.tokenPost(params)(fetch, basePath);
        },
    }
};

