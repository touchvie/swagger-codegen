/**
 * Dive API
 * This is the Dive third party API official documentation
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "qs";
import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://pre-api.touchvie.com/v1".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface AccessToken {
    /**
     * Auth token, must be included on every API request
     */
    "access_token"?: string;
    /**
     * Token type
     */
    "token_type"?: AccessTokenTokenTypeEnum;
    /**
     * Allows to issue new access tokens without resending client credentials
     */
    "refresh_token"?: string;
    /**
     * Expiration time (in seconds).
     */
    "expires_in"?: number;
    /**
     * Granted auth scope
     */
    "scope"?: AccessTokenScopeEnum;
}

export type AccessTokenTokenTypeEnum = "bearer";
export type AccessTokenScopeEnum = "device";
export interface AuthError {
    /**
     * Short error identifier
     */
    "error"?: string;
    /**
     * Extended error description
     */
    "error_description"?: string;
}

/**
 * Award nominee or winner info
 */
export interface AwardData {
    /**
     * Name of the prize
     */
    "title": string;
    /**
     * Name of the nominee / winner
     */
    "value": string;
}

/**
 * CardContainer composed by a list of awards with nominees and winners
 */
export interface Awards extends CardContainer {
    /**
     * Awards container content type
     */
    "content_type": AwardsContentTypeEnum;
    "data": Array<AwardsData>;
}

export type AwardsContentTypeEnum = "awards";
export interface AwardsData {
    /**
     * Award name
     */
    "title": string;
    "nominee"?: Array<AwardData>;
    "winner"?: Array<AwardData>;
}

/**
 * Basic Dive data unit, represents an item of a given category
 */
export interface Card {
    /**
     * Card unique identifier
     */
    "card_id": string;
    /**
     * Card version for a given movie and scene
     */
    "version"?: string;
    /**
     * Card type
     */
    "typeOfCard": CardTypeOfCardEnum;
    /**
     * Card content locale
     */
    "locale": string;
    /**
     * Card title
     */
    "title": string;
    /**
     * Card subtitle (might be empty)
     */
    "subtitle"?: string;
    "image"?: ImageData;
    "info"?: Array<CardContainer>;
    "relations"?: Array<RelationModule>;
}

export type CardTypeOfCardEnum = "movie" | "serie" | "person" | "character" | "vehicle" | "fashion" | "location" | "historic" | "trivia" | "quote" | "ost" | "home" | "technology" | "art" | "song" | "look" | "weapon" | "leisure_sport" | "health_beauty" | "food_drink" | "fauna_flora" | "business" | "reference" | "chapter";
/**
 * Card static data container. It's content depends on the 'type' parameter value and is represented by the schema of the same name
 */
export interface CardContainer {
    /**
     * Card container format type, determines the format of the 'data' field
     */
    "typeOfContainer": CardContainerTypeOfContainerEnum;
}

export type CardContainerTypeOfContainerEnum = "text" | "listing" | "rating" | "map" | "link" | "awards" | "catalog" | "seasons" | "image";
/**
 * CardContainer composed by additional information of a catalog item (movie, serie or chapter)
 */
export interface Catalog extends CardContainer {
    /**
     * Catalog container content type
     */
    "content_type": CatalogContentTypeEnum;
    "data": Array<CatalogData>;
}

export type CatalogContentTypeEnum = "movie" | "chapter" | "serie";
export interface CatalogData {
    /**
     * URL of an additional background image for this catalog element
     */
    "background_image"?: string;
    /**
     * Name of the director
     */
    "director": string;
    /**
     * List of genres of this catalog entry
     */
    "genres": Array<string>;
    /**
     * Original language title
     */
    "original_title": string;
    /**
     * Length of the movie or chapter, or average length of serie chapters, in minutes
     */
    "runtime": number;
    /**
     * Year of production
     */
    "year": number;
    /**
     * Index of the chapter inside its season (only for content_type=chapter)
     */
    "chapter_index"?: number;
    /**
     * Index of the season where the chapter belongs (only for content_type=chapter)
     */
    "season_index"?: number;
    "sync"?: CatalogSync;
}

/**
 * Dive interactive capabilities of this catalog item
 */
export interface CatalogSync {
    /**
     * Indicates if this catalog item can be synchronized
     */
    "is_synchronizable": boolean;
}

export interface ChannelStatus {
    /**
     * Provided channel ID
     */
    "channel_id"?: string;
    /**
     * True if channel is broadcasting synchronizable content, False otherwise
     */
    "ready"?: boolean;
}

/**
 * List of related pairs of cards, each pair having a relationship type between both cards
 */
export interface Duple extends RelationModule {
    /**
     * Duple module content type, defines what kind of relations are contained in the module
     */
    "content_type": DupleContentTypeEnum;
    "data": Array<DupleData>;
}

export type DupleContentTypeEnum = "casting" | "filmography" | "played_by" | "worn_by" | "featured_in";
export interface DupleData {
    /**
     * Indicates the relationship between the pair of cards (from > rel_type > to)
     */
    "rel_type": string;
    "from": Card;
    "to"?: Card;
}

/**
 * CardContainer composed by a list of images with source attribution
 */
export interface Image extends CardContainer {
    /**
     * Image container content type
     */
    "content_type": ImageContentTypeEnum;
    "data": Array<ImageData>;
}

export type ImageContentTypeEnum = "gallery";
/**
 * Linked image URL and additional information
 */
export interface ImageData {
    /**
     * Image thumbnail URL
     */
    "thumb": string;
    /**
     * Full size image URL
     */
    "full": string;
    /**
     * Image anchor X axis (percent)
     */
    "anchor_x": number;
    /**
     * Image anchor Y axis (percent)
     */
    "anchor_y": number;
    "source": SourceData;
}

/**
 * CardContainer composed by a list of links to external media resources with source attribution
 */
export interface Link extends CardContainer {
    /**
     * Link container content type
     */
    "content_type": LinkContentTypeEnum;
    "data": Array<LinkData>;
}

export type LinkContentTypeEnum = "trailer" | "video" | "music";
export interface LinkData {
    /**
     * URL of the external resource
     */
    "url": string;
    "source": SourceData;
}

/**
 * CardContainer composed by a list of pairs of label - value items
 */
export interface Listing extends CardContainer {
    /**
     * Listing container content type
     */
    "content_type": ListingContentTypeEnum;
    "data": Array<ListingData>;
}

export type ListingContentTypeEnum = "basic_data" | "specs";
export interface ListingData {
    /**
     * Item label
     */
    "text": string;
    /**
     * Item value
     */
    "value": string;
}

/**
 * CardContainer composed by a map of a given location
 */
export interface Map extends CardContainer {
    /**
     * Map container content type
     */
    "content_type": MapContentTypeEnum;
    "data": Array<MapData>;
}

export type MapContentTypeEnum = "location";
export interface MapData {
    /**
     * Value of the location latitude, in decimal format degrees
     */
    "latitude": number;
    /**
     * Value of the location longitude, in decimal format degrees
     */
    "longitude": number;
    /**
     * Zoom value, defines the height coordinate over the given location
     */
    "zoom": number;
}

export interface MovieStatus {
    /**
     * Provided client movie ID
     */
    "movie_id"?: string;
    /**
     * True if movie can be synchronized via this API, False otherwise.
     */
    "ready"?: boolean;
}

/**
 * CardContainer composed by a list of external ratings with source attribution
 */
export interface Rating extends CardContainer {
    /**
     * Rating container content type
     */
    "content_type": RatingContentTypeEnum;
    "data": Array<RatingData>;
}

export type RatingContentTypeEnum = "rating";
export interface RatingData {
    /**
     * Rating value
     */
    "value": string;
    "source"?: SourceData;
}

/**
 * Relation modules provide lists of cards related to the current one. It's contents depend on the module 'type' attribute
 */
export interface RelationModule {
    /**
     * Relation module type, defines the contained data structure
     */
    "typeOfRelation": RelationModuleTypeOfRelationEnum;
}

export type RelationModuleTypeOfRelationEnum = "single" | "duple";
/**
 * Serie seasons listing
 */
export interface Seasons extends CardContainer {
    /**
     * Seasons container content type
     */
    "content_type": SeasonsContentTypeEnum;
    "data": Array<SeasonsData>;
}

export type SeasonsContentTypeEnum = "seasons";
export interface SeasonsChapters {
    /**
     * Index of the chapter inside this season
     */
    "chapter_index": number;
    /**
     * ID of the chapter card
     */
    "card_id": string;
}

export interface SeasonsData {
    /**
     * Index of the season
     */
    "season_index": number;
    /**
     * Comma separated list of season creators
     */
    "creators": string;
    "image": ImageData;
    /**
     * Year of production of this season
     */
    "year": number;
    /**
     * List of season chapters
     */
    "chapters": Array<SeasonsChapters>;
}

/**
 * List of related single cards. The relation type is defined by the module content type
 */
export interface Single extends RelationModule {
    /**
     * Single module content type, defines what kind of relations are contained in the module
     */
    "content_type": SingleContentTypeEnum;
    "data": Array<Card>;
}

export type SingleContentTypeEnum = "trivias" | "directors" | "appears_in" | "full_looks" | "look_fashion" | "fashion_set" | "full_home" | "home_deco" | "tracklist" | "sounds_in" | "is_part_of" | "is_chapter_of" | "wears";
/**
 * Information regarding the source of any API item
 */
export interface SourceData {
    /**
     * Name of the source
     */
    "name": string;
    /**
     * URL of the source
     */
    "url": string;
    /**
     * Disclaimer text of the source
     */
    "disclaimer"?: string;
    /**
     * URL of the source icon
     */
    "image"?: string;
}

/**
 * CardContainer composed by a block of text with an optional source attribution
 */
export interface Text extends CardContainer {
    /**
     * Text container content type
     */
    "content_type": TextContentTypeEnum;
    "data": Array<TextData>;
}

export type TextContentTypeEnum = "overview" | "curiosity" | "description" | "biography" | "reference" | "quote";
export interface TextData {
    /**
     * Informational text
     */
    "text": string;
    "source"?: SourceData;
}



/**
 * DefaultApi - fetch parameter creator
 */
export const DefaultApiFetchParamCreator = {
    /** 
     * Full card detail
     * Retrieves a full card detail, and optionally its relations to other cards
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Provided card ID (value of the &#39;card_id&#39; field)
     * @param version Provided card version (value of the &#39;version&#39; field)
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getCardVersion(params: {  "authorization": string; "cardId": string; "version": string; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getCardVersion");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling getCardVersion");
        }
        // verify required parameter "version" is set
        if (params["version"] == null) {
            throw new Error("Missing required parameter version when calling getCardVersion");
        }
        const baseUrl = `/cards/{card_id}/versions/{version}`
            .replace(`{${"card_id"}}`, `${ params["cardId"] }`)
            .replace(`{${"version"}}`, `${ params["version"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = {...urlObj.query, 
            "relations": params["relations"],
            "image_size": params["imageSize"],
        };
        let fetchMethod = { method: "GET" };
        let fetchOptions: RequestInit = {...fetchMethod, ...options};

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = {...contentTypeHeader,
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],"Content-Type": params["contentType"],
        };
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Channel sync availability
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    getReadyChannels(params: {  "authorization": string; "channelIdList": Array<string>; "acceptLanguage"?: string; "contentType"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getReadyChannels");
        }
        // verify required parameter "channelIdList" is set
        if (params["channelIdList"] == null) {
            throw new Error("Missing required parameter channelIdList when calling getReadyChannels");
        }
        const baseUrl = `/channels/{channel_id_list}/ready`
            .replace(`{${"channel_id_list"}}`, `${ params["channelIdList"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchMethod = { method: "GET" };
        let fetchOptions: RequestInit = {...fetchMethod, ...options};

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = {...contentTypeHeader,
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],"Content-Type": params["contentType"],
        };
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Movie sync availability
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    getReadyMovies(params: {  "authorization": string; "clientMovieIdList": Array<string>; "acceptLanguage"?: string; "contentType"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getReadyMovies");
        }
        // verify required parameter "clientMovieIdList" is set
        if (params["clientMovieIdList"] == null) {
            throw new Error("Missing required parameter clientMovieIdList when calling getReadyMovies");
        }
        const baseUrl = `/movies/{client_movie_id_list}/ready`
            .replace(`{${"client_movie_id_list"}}`, `${ params["clientMovieIdList"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchMethod = { method: "GET" };
        let fetchOptions: RequestInit = {...fetchMethod, ...options};

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = {...contentTypeHeader,
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],"Content-Type": params["contentType"],
        };
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * One-shot channel scene
     * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticChannelScene(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getStaticChannelScene");
        }
        // verify required parameter "channelId" is set
        if (params["channelId"] == null) {
            throw new Error("Missing required parameter channelId when calling getStaticChannelScene");
        }
        const baseUrl = `/channels/{channel_id}/static`
            .replace(`{${"channel_id"}}`, `${ params["channelId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = {...urlObj.query, 
            "relations": params["relations"],
            "image_size": params["imageSize"],
        };
        let fetchMethod = { method: "GET" };
        let fetchOptions: RequestInit = {...fetchMethod, ...options};

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = {...contentTypeHeader,
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],"Content-Type": params["contentType"],
        };
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * One-shot movie scene
     * Retrieves the current list of cards related to the given movie scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticMovieScene(params: {  "authorization": string; "clientMovieId": string; "timestamp": number; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getStaticMovieScene");
        }
        // verify required parameter "clientMovieId" is set
        if (params["clientMovieId"] == null) {
            throw new Error("Missing required parameter clientMovieId when calling getStaticMovieScene");
        }
        // verify required parameter "timestamp" is set
        if (params["timestamp"] == null) {
            throw new Error("Missing required parameter timestamp when calling getStaticMovieScene");
        }
        const baseUrl = `/movies/{client_movie_id}/static/{timestamp}`
            .replace(`{${"client_movie_id"}}`, `${ params["clientMovieId"] }`)
            .replace(`{${"timestamp"}}`, `${ params["timestamp"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = {...urlObj.query, 
            "relations": params["relations"],
            "image_size": params["imageSize"],
        };
        let fetchMethod = { method: "GET" };
        let fetchOptions: RequestInit = {...fetchMethod, ...options};

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = {...contentTypeHeader,
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],"Content-Type": params["contentType"],
        };
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Token endpoint
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "contentType"?: string; "deviceId"?: string; "refreshToken"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postToken");
        }
        // verify required parameter "grantType" is set
        if (params["grantType"] == null) {
            throw new Error("Missing required parameter grantType when calling postToken");
        }
        const baseUrl = `/token`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = {...urlObj.query, 
            "grant_type": params["grantType"],
        };
        let fetchMethod = { method: "POST" };
        let fetchOptions: RequestInit = {...fetchMethod, ...options};

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "device_id": params["deviceId"],
            "refresh_token": params["refreshToken"],
        });
        fetchOptions.headers = {...contentTypeHeader,
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],"Content-Type": params["contentType"],
        };
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = {
    /** 
     * Full card detail
     * Retrieves a full card detail, and optionally its relations to other cards
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Provided card ID (value of the &#39;card_id&#39; field)
     * @param version Provided card version (value of the &#39;version&#39; field)
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getCardVersion(params: { "authorization": string; "cardId": string; "version": string; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Card> {
        const fetchArgs = DefaultApiFetchParamCreator.getCardVersion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Channel sync availability
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    getReadyChannels(params: { "authorization": string; "channelIdList": Array<string>; "acceptLanguage"?: string; "contentType"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChannelStatus>> {
        const fetchArgs = DefaultApiFetchParamCreator.getReadyChannels(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Movie sync availability
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    getReadyMovies(params: { "authorization": string; "clientMovieIdList": Array<string>; "acceptLanguage"?: string; "contentType"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MovieStatus>> {
        const fetchArgs = DefaultApiFetchParamCreator.getReadyMovies(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * One-shot channel scene
     * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticChannelScene(params: { "authorization": string; "channelId": string; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Card>> {
        const fetchArgs = DefaultApiFetchParamCreator.getStaticChannelScene(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * One-shot movie scene
     * Retrieves the current list of cards related to the given movie scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticMovieScene(params: { "authorization": string; "clientMovieId": string; "timestamp": number; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Card>> {
        const fetchArgs = DefaultApiFetchParamCreator.getStaticMovieScene(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Token endpoint
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: { "authorization": string; "grantType": string; "acceptLanguage"?: string; "contentType"?: string; "deviceId"?: string; "refreshToken"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = DefaultApiFetchParamCreator.postToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /** 
     * Full card detail
     * Retrieves a full card detail, and optionally its relations to other cards
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Provided card ID (value of the &#39;card_id&#39; field)
     * @param version Provided card version (value of the &#39;version&#39; field)
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getCardVersion(params: {  "authorization": string; "cardId": string; "version": string; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getCardVersion(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Channel sync availability
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    getReadyChannels(params: {  "authorization": string; "channelIdList": Array<string>; "acceptLanguage"?: string; "contentType"?: string; }, options?: any) {
        return DefaultApiFp.getReadyChannels(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Movie sync availability
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     */
    getReadyMovies(params: {  "authorization": string; "clientMovieIdList": Array<string>; "acceptLanguage"?: string; "contentType"?: string; }, options?: any) {
        return DefaultApiFp.getReadyMovies(params, options)(this.fetch, this.basePath);
    }
    /** 
     * One-shot channel scene
     * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticChannelScene(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getStaticChannelScene(params, options)(this.fetch, this.basePath);
    }
    /** 
     * One-shot movie scene
     * Retrieves the current list of cards related to the given movie scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticMovieScene(params: {  "authorization": string; "clientMovieId": string; "timestamp": number; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getStaticMovieScene(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Token endpoint
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
     * @param contentType application/json
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "contentType"?: string; "deviceId"?: string; "refreshToken"?: string; }, options?: any) {
        return DefaultApiFp.postToken(params, options)(this.fetch, this.basePath);
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Full card detail
         * Retrieves a full card detail, and optionally its relations to other cards
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param cardId Provided card ID (value of the &#39;card_id&#39; field)
         * @param version Provided card version (value of the &#39;version&#39; field)
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
         * @param imageSize Size of the images returned in the response
         */
        getCardVersion(params: {  "authorization": string; "cardId": string; "version": string; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getCardVersion(params, options)(fetch, basePath);
        },
        /** 
         * Channel sync availability
         * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param channelIdList List of client channel IDs as a comma separated list
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         */
        getReadyChannels(params: {  "authorization": string; "channelIdList": Array<string>; "acceptLanguage"?: string; "contentType"?: string; }, options?: any) {
            return DefaultApiFp.getReadyChannels(params, options)(fetch, basePath);
        },
        /** 
         * Movie sync availability
         * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         */
        getReadyMovies(params: {  "authorization": string; "clientMovieIdList": Array<string>; "acceptLanguage"?: string; "contentType"?: string; }, options?: any) {
            return DefaultApiFp.getReadyMovies(params, options)(fetch, basePath);
        },
        /** 
         * One-shot channel scene
         * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param channelId Client channel ID
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
         * @param imageSize Size of the images returned in the response
         */
        getStaticChannelScene(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getStaticChannelScene(params, options)(fetch, basePath);
        },
        /** 
         * One-shot movie scene
         * Retrieves the current list of cards related to the given movie scene
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientMovieId Client movie ID being played
         * @param timestamp Current movie timestamp in seconds
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         * @param relations Indicates if the received scene cards should contain the scene hierarchy (true) or be a flat list of the main scene items (false)
         * @param imageSize Size of the images returned in the response
         */
        getStaticMovieScene(params: {  "authorization": string; "clientMovieId": string; "timestamp": number; "acceptLanguage"?: string; "contentType"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getStaticMovieScene(params, options)(fetch, basePath);
        },
        /** 
         * Token endpoint
         * The token endpoint is used to obtain access tokens which allow clients to make API requests
         * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
         * @param grantType Grant type used to obtain the token.
         * @param acceptLanguage Client locale, as &lt;language&gt;-&lt;country&gt;
         * @param contentType application/json
         * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
         * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
         */
        postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "contentType"?: string; "deviceId"?: string; "refreshToken"?: string; }, options?: any) {
            return DefaultApiFp.postToken(params, options)(fetch, basePath);
        },
    };
};

