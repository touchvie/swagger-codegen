// APIHelper.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import UIKit
import Security

//API versions
let API_VERSION = "v1/";
let SYNC_AUDIO_VERSION = "v6"
let CHUNK_VERSION = "v4";
let CARRUSEL_CONFIG_VERSION = "";

//Token
let DEVICE_TOKEN = "deviceToken";

#if PRO
let DIVE_KEY = "diveToken";
let REFRESH_TOKEN = "refreshToken";
let FACEBOOK_KEY = "facebookToken";
#elseif DEMO
let DIVE_KEY = "diveTokenDemo";
let REFRESH_TOKEN = "refreshTokenDemo";
let FACEBOOK_KEY = "facebookTokenDemo";
#elseif BETA
let DIVE_KEY = "diveTokenBeta";
let REFRESH_TOKEN = "refreshTokenBeta";
let FACEBOOK_KEY = "facebookTokenBeta";
#elseif PRE
let DIVE_KEY = "diveTokenPre";
let REFRESH_TOKEN = "refreshTokenPre";
let FACEBOOK_KEY = "facebookTokenPre";
#else
let DIVE_KEY = "diveTokenDev";
let REFRESH_TOKEN = "refreshTokenDev";
let FACEBOOK_KEY = "facebookTokenDev";
#endif

//Dive Get Token Keys
let DIVE_MOBILE_IOS = "Basic " + "dive_mobile_ios:zrCyEz2qZHRzEWXZkGHxjUB53xhtKjdR".toBase64();
let DIVE_TABLET_IOS = "Basic " + "dive_tablet_ios:NTKnUb7ioj98yVn3qa3VN7TPXmrLdbeN".toBase64();
let EMDT_MOBILE_IOS = "Basic " + "emdt_mobile_ios:NHMqijosE7iErP99z4YmyQEf6qtNbBK4".toBase64();
let EMDT_TABLET_IOS = "Basic " + "emdt_tablet_ios:Cj2vxMukjkVEadep8FSJ9sUUcg5JEAKz".toBase64();

//CUSTOM ERRORS
protocol DiveErrorProtocol: Error {
    
    var localizedTitle: String { get }
    var localizedDescription: String { get }
    var code: Int { get }
}

struct TokenWithoutGrantType: DiveErrorProtocol {
    
    var localizedTitle: String = "ERROR: TokenWithoutGrantType"
    var localizedDescription: String = "When we try to get data of keychain, there isnt any method to obtain grantType"
    var code: Int = 1;
}

public class UserAgentData{
    
    enum AppName: String {
        case DIVE = "dive"
        case EMDT = "emdt"
    }
    
    public var appName : String;
    public var appVersion : String;
    public let OS : String = "iOS";
    public var OSVersion : String;
    public var deviceModel : String;
    public var deviceLocale : String;
    
    init(_appName : AppName){
    
        self.appName = _appName.rawValue;
        self.appVersion = APIHelper.getAppVersion();
        self.OSVersion = APIHelper.getOSVersion();
        self.deviceModel = APIHelper.getDeviceModel();
        self.deviceLocale = APIHelper.getLanguage();
    }
}


class APIHelper {

    static func getAppVersion()-> String{
        return (Bundle.main.infoDictionary!["CFBundleShortVersionString"] as? String)!;
    }
    
    static func getOSVersion()-> String{
        return UIDevice.current.systemVersion;
    }
    
    static func getDeviceModel()->String{
        return UIDevice.current.modelName;
    }
    
    static func getUserAgent(_appName : UserAgentData.AppName)->String{
        
        let userAgentData = UserAgentData(_appName: _appName);
        
        let userAgentString = userAgentData.appName + "/" + userAgentData.appVersion + "/" + userAgentData.OS + "/" + userAgentData.OSVersion + "/" + userAgentData.deviceModel + "/" + userAgentData.deviceLocale;
        
        return userAgentString;
    }

    static func getUserAgent()->String{
        return "";
    }

    static func rejectNil(_ source: [String:Any?]) -> [String:Any]? {
        var destination = [String:Any]()
        for (key, nillableValue) in source {
            if let value: Any = nillableValue {
                destination[key] = value
            }
        }

        if destination.isEmpty {
            return nil
        }
        return destination
    }

    static func rejectNilHeaders(_ source: [String:Any?]) -> [String:String] {
        var destination = [String:String]()
        for (key, nillableValue) in source {
            if let value: Any = nillableValue {
                destination[key] = "\(value)"
            }
        }
        return destination
    }

    static func convertBoolToString(_ source: [String: Any]?) -> [String:Any]? {
        guard let source = source else {
            return nil
        }
        var destination = [String:Any]()
        let theTrue = NSNumber(value: true as Bool)
        let theFalse = NSNumber(value: false as Bool)
        for (key, value) in source {
            switch value {
            case let x where x as? NSNumber === theTrue || x as? NSNumber === theFalse:
                destination[key] = "\(value as! Bool)" as Any?
            default:
                destination[key] = value
            }
        }
        return destination
    }


    static func mapValuesToQueryItems(values: [String:Any?]) -> [URLQueryItem]? {
        let returnValues = values
            .filter { $0.1 != nil }
            .map { (item: (_key: String, _value: Any?)) -> URLQueryItem in
                URLQueryItem(name: item._key, value:"\(item._value!)")
            }
        if returnValues.count == 0 {
            return nil
        }
        return returnValues
    }

    static func getLanguage()->String{
        
        var locale = NSLocale.current.identifier
        locale = locale.replacingOccurrences(of: "_", with: "-");
        
        return locale;
    }

}

let kSecClassGenericPasswordValue = String(format: kSecClassGenericPassword as String)
let kSecClassValue = String(format: kSecClass as String)
let kSecAttrServiceValue = String(format: kSecAttrService as String)
let kSecValueDataValue = String(format: kSecValueData as String)
let kSecMatchLimitValue = String(format: kSecMatchLimit as String)
let kSecReturnDataValue = String(format: kSecReturnData as String)
let kSecMatchLimitOneValue = String(format: kSecMatchLimitOne as String)
let kSecAttrAccountValue = String(format: kSecAttrAccount as String)

struct KeychainAccess {
    
    func setPasscode(identifier: String, passcode: String) {
        if let dataFromString = passcode.data(using: String.Encoding.utf8) {
            let keychainQuery = [
                kSecClassValue: kSecClassGenericPasswordValue,
                kSecAttrServiceValue: identifier,
                kSecValueDataValue: dataFromString
                ] as CFDictionary
            SecItemDelete(keychainQuery)
            print(SecItemAdd(keychainQuery, nil))
        }
    }
    
    func getPasscode(identifier: String) -> String? {
        let keychainQuery = [
            kSecClassValue: kSecClassGenericPasswordValue,
            kSecAttrServiceValue: identifier,
            kSecReturnDataValue: kCFBooleanTrue,
            kSecMatchLimitValue: kSecMatchLimitOneValue
            ] as  CFDictionary
        var dataTypeRef: AnyObject?
        let status: OSStatus = SecItemCopyMatching(keychainQuery, &dataTypeRef)
        var passcode: String?
        if (status == errSecSuccess) {
            if let retrievedData = dataTypeRef as? Data,
                let result = String(data: retrievedData, encoding: String.Encoding.utf8) {
                passcode = result as String
            }
        }
        else {
            print("Nothing was retrieved from the keychain. Status code \(status)")
        }
        return passcode
    }
}

public class AuthManager: NSObject {
    
    private struct AuthData {
        var username : String?;
        var password : String?;
        var token : String?;
        var refresh_token : String?;
        var device_id : String?;
    }
    
    private static var autorization : String?;
    
    public class func setAutorization(_authHeader : String){
        self.autorization = _authHeader;
    }

    public class func postToken(_deviceID : String? = nil, _userName : String? = nil, _password : String? = nil, _fbToken : String? = nil, _googleToken : String? = nil, _completion: @escaping ((_ _response : Response<AccessTokenResponse>?, _ _error : Error?) -> Void)){
        
        //let _authorization = "emdt_mobile_ios:NHMqijosE7iErP99z4YmyQEf6qtNbBK4".toBase64();
       
        
        var _grantType : DiveAPI.grantType_postToken? = nil;
        var _authData = AuthData();
        
        //By refreshToken
        if let refreshToken = self.getRefreshToken(){
            _grantType = DiveAPI.grantType_postToken.REFRESH_TOKEN;
            _authData.refresh_token = refreshToken;
        }
        
        //by saved deviceID
        if let savedDeviceID = self.getDeviceToken(){
            _grantType = DiveAPI.grantType_postToken.DIVE_DEVICE;
            _authData.device_id = savedDeviceID;
        }else
        //by device ID
        if (_deviceID != nil){
            self.saveDeviceTokenInKeyChain(token: _deviceID!);
            _grantType = DiveAPI.grantType_postToken.DIVE_DEVICE;
            _authData.device_id = _deviceID!;
        }
    
        //By token (fb or google)
        if (_fbToken != nil || _googleToken != nil){
            
            if (_fbToken != nil){
                _grantType = DiveAPI.grantType_postToken.FACEBOOK;
                _authData.token = _fbToken;
                
            }
            if (_googleToken != nil){
                _grantType = DiveAPI.grantType_postToken.GOOGLE;
                _authData.token = _googleToken;
            }
        }

        //By userName and pass
        if(_userName != nil && _password != nil){
            _grantType = DiveAPI.grantType_postToken.PASSWORD;
            _authData.username = _userName;
            _authData.password = _password;
        }
        
        if (_grantType != nil){

            DiveAPI.postTokenWithRequestBuilder(grantType: _grantType!, username: _authData.username, password: _authData.password, token: _authData.token, deviceId: _authData.device_id, refreshToken: _authData.refresh_token, _completion: { (_response : Response<AccessTokenResponse>?, _error : Error?) in
                
                //store the new token in the keychain
                self.saveDiveTokenInKeyChain(token: "Bearer " + _response!.body!.accessToken!);
                
                //update the header with the new token
                DiveAPI.updateTokenCommonHeader();
                
                //commonHeaders["Authorization"] = AuthData.getDiveToken();
                
                _completion(_response, _error);
                
            }, _headers : ["Authorization" : self.autorization!]);
        }
        //ERROR: postToken without grantType or Data
        else{
            
            let error = TokenWithoutGrantType();
            _completion(nil, error);
        }
        
        //print(postTokenRB.parameters!);
        //print(postTokenRB.headers);
        //print(postTokenRB.URLString);
    }
    
    class func saveDiveTokenInKeyChain(token : String){
        let keychainAccess = KeychainAccess();
        keychainAccess.setPasscode(identifier: DIVE_KEY, passcode:token);
    }
    
    class func saveFacebookTokenInKeyChain(token : String){
        let keychainAccess = KeychainAccess();
        keychainAccess.setPasscode(identifier: FACEBOOK_KEY, passcode:token);
    }
    
    class func saveDeviceTokenInKeyChain(token : String){
        let keychainAccess = KeychainAccess();
        keychainAccess.setPasscode(identifier: DEVICE_TOKEN, passcode:token);
    }
    
    class func saveRefreshTokenInKeyChain(token : String){
        let keychainAccess = KeychainAccess();
        keychainAccess.setPasscode(identifier: REFRESH_TOKEN, passcode:token);
    }
    
    class func getDiveToken()->String?{
        let keychainAccess = KeychainAccess();
        return keychainAccess.getPasscode(identifier: DIVE_KEY);
    }
    
    class func getFacebookToken()->String?{
        let keychainAccess = KeychainAccess();
        return keychainAccess.getPasscode(identifier: FACEBOOK_KEY);
    }
    
    class func getDeviceToken()->String?{
        let keychainAccess = KeychainAccess();
        return keychainAccess.getPasscode(identifier: DEVICE_TOKEN);
    }
    
    class func getRefreshToken()->String?{
        let keychainAccess = KeychainAccess();
        return keychainAccess.getPasscode(identifier: REFRESH_TOKEN);
    }
}


